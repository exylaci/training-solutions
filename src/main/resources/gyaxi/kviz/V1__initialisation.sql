CREATE TABLE if NOT EXISTS questions(
   id INT AUTO_INCREMENT PRIMARY KEY,
   question VARCHAR(600),
   answer1 VARCHAR(200),
   answer2 VARCHAR(200),
   answer3 VARCHAR(200),
   answer4 VARCHAR(200));

INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik állítás hamis az alábbiak közül?', 'A szemétgyűjtő mechanizmust a virtuális gép biztosítja.', 'A lefordított bájtkód platform független.', 'Az Oracle szállítja a JDK-t, mely a JRE és olyan (főleg) parancssori fejlesztőeszközök, mint a fordító. A JRE-nek része a virtuális gép és az osztálykönyvtár.', '@A virtuális gép elemzi a forráskódot, és soronként futtatja.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik állítás hamis az alábbiak közül?', 'Java-ban nincs standard projektstruktúra', 'A Maven alapelve a convention over configuration', '@Az IDE nem tud Maven nélkül működni', 'A Maven parancssorból indítható, nem szükséges fejlesztőeszköz a használatához');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik könyvtárba kell elhelyezni a fájlokat Maven esetén? A megadott könyvtárnevek mindig a projekt főkönyvtárától értelmezendők.', '@Az src/main/java könyvtárba kell elhelyezni a Java forrásfájlokat és az src/test/java könyvtárba a teszteseteket', 'A main könyvtárba kell elhelyezni a Java forrásfájlokat és a test könyvtárba a teszteseteket', 'A main/src/java könyvtárba kell elhelyezni a Java forrásfájlokat és a test/src/java könyvtárba a teszteseteket', 'A java könyvtárba kell elhelyezni a Java forrásfájlokat és a java/test könyvtárba a teszteseteket');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mi azonosítja a Maven projektet (koordináták)?', 'A projekt neve', 'A projekt csomagneve és neve', 'A projekt groupId, artifactId tulajdonsága', '@A projekt groupId, artifactId és version tulajdonsága');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik állítás igaz?', '@Nem érdemes a forrásállományokat csomagokon kívül elhelyezni', 'Ha az A osztályból el akarjuk érni egy másik csomagban lévő B osztályt, akkor csak importálással tudjuk azt elérni', 'A csomag neve és a könyvtár neve eltérhet', 'Az A osztályból csak akkor használható a B osztály, ha beimportáljuk');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik csomag osztályai kerülnek automatikusan importálására, így azokat használhatjuk import nélkül is?', 'Nincs ilyen csomag, mindig importálni kell', '@A java.lang csomag automatikusan importálásra kerül', 'A String csomag automatikusan importálásra kerül', 'A common csomag automatikusan importálásra kerül');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik hamis a következő állítások közül?', 'Az osztály fő építőelemei a konstruktorok, metódusok és attribútumok', '@Konstruktor megadása kötelező', 'A getterek és setterek metódusok', 'Az osztály publikus metódusai adják annak interfészét (attribútumokat ne tegyük publikusra)');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik helyes main() deklaráció?', 'public static int main(String[] args)', 'public final int main(String args)', 'public final void main(String args[])', '@public static void main(String[] args)');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik hamis a kódolási konvenciókkal kapcsolatban?', 'Változónevek első karaktere, ha betű, kisbetű legyen', 'Metódusnevek első karaktere, ha betű, kisbetű legyen', '@Osztálynevek első karaktere, ha betű, kisbetű legyen', 'A konstans értékek nevei csupa nagybetűvel és a szavak között aláhúzás karakterrel szerepeljenek');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik igaz az alábbi állítások közül?', 'Egész literálok megadása csak tizes számrendszerben történhet', 'Változót a következőképpen deklarálunk: let a = 0;', 'Változót a következőképpen deklarálunk: var a = 0;', '@Változót a következőképpen deklarálunk: int a = 0;');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik helyes definíció, amennyiben csak a beépített osztálykönyvtárat használjuk?', 'Int i = 0;', '@int i = 0;', 'arraylist names = new List', 'char c = null;');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mely állítás igaz a String osztályra?', 'Hosszát a size() metódussal lehet lekérni', '@Állapota nem módosítható', 'A toUpperCase() metódus az objektum állapotát módosítja úgy, hogy a kisbetűket nagybetűkre cseréli', 'Értéke nem lehet null');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Válaszd ki, hogy melyik értékadás a helyes!', 'String s = 5;', 'String s = \'5\';', '@String s = "";', 'String s = (String) 5;');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik kód megfelelő Java String-ek összehasonlítására?', 's1 = s2', 's1 == s2', '@s1.equals(s2)', 'Mindhárom');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\nString s = "dog";\r\ns.toUpperCase();\r\nSystem.out.println(s);', '@dog', 'DOG', 'Nem fordul le', 'Üres sztringet');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik utasítással lehet egy ötelemű tömböt definiálni?', '@int[] x = {0, 1, 2, 3, 4};', 'int[4] x;', 'int array[] = int{5};', 'int array[5] = new int[];');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\nint[] i = {1, 2, 3, 4};\r\nSystem.out.println(i[4]);', 'Nem fordul le', '0', '4', '@IndexOutOfBoundsException kivétel keletkezik');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\nint[][] i = new int[3][3];\r\nSystem.out.println(i[2][2]);', 'Nem fordul le', '@0', '2', 'IndexOutOfBoundsException kivétel keletkezik');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Milyen módon lehet egy listát feltölteni elemekkel?', 'List names = {"Joe", "John"};', '@List names = Arrays.asList("Joe", "John");', 'List names = new List;', 'List names = new ArrayList;');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik állítás hamis a következők közül?', 'A következő utasítás egy üres listát hoz létre: List names = new ArrayList();', '@A lista elemeit a következőképp adhatjuk meg: List names = {"Joe", "Jane"};', 'A lista mérete a size() metódussal kérdezhető le', 'A listába új elemeket lehet hozzáadni, és elemeket lehet törölni');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik hamis a következő állítások közül?', 'A tömb mérete a következőképp kérdezhető le: names.length', 'A String hossza a következőképp kérdezhető le: name.length()', '@Egy lista mérete a következőképp kérdezhető le: names.length()', 'A tömb és a lista indexelése nullától kezdődik');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik állítás igaz a következők közül?', 'A tömb második eleméhez hozzáférhetünk a következő módon: names.get(1)', 'A lista harmadik eleméhez hozzáférhetünk a következő módon: names.get(3)', '@A lista kiírása esetén (System.out.println) a lista elemei vesszővel elválasztva kerülnek kiírásra (toString metódus tehát helyesen implementált)', 'A tömb contains() metódusával lehet megnézni, hogy egy elem szerepel-e a tömbben');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Hogyan járjuk be egy lista elemeit?', '@for (String s: list) {System.out.println(s);}', 'for (String s in list) {System.out.println(s);}', 'for each (String s: list) {System.out.println(s);}', 'for (int i = 0; i<list.length() ; i++) {System.out.println(list.get(i));}');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mely állítás igaz a következők közül?', 'Ha final kulcsszóval deklarálunk egy lokális változót, akkor annak a deklarációkor értéket kell adni', 'Ha final kulcsszóval deklarálunk egy lokális változót, akkor bármikor adhatunk neki értéket a metóduson belül', '@Ha final kulcsszóval deklarálunk egy lokális változót, akkor az első használat előtt adnunk kell neki értéket', 'Ha final kulcsszóval deklarálunk egy lokális változót, akkor int típus esetén az értéke mindig 0');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\npublic class Incrementer {\r\n  public int inc(int i) {\r\n    return i + 1;\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    int i = 5;\r\n    System.out.println(inc(i));\r\n  }\r\n}', '@Nem fordul le', '5', '6', 'Kivételt dob');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik hamis az alábbiak közül az attribútumokra vonatkozóan?', 'Az attribútumok kezdőértékkel rendelkeznek, pl.egész számok esetén ez 0', '@A lokális változók kezdőértékkel rendelkeznek, pl. egész számok esetén ez 0', 'Deklaráljuk az attribútumokat private módosítószóval, és csak metódusokon (pl. getter és setter) keresztül férjünk hozzá', 'Attribútumok értékei pl. konstruktorban is inicializálhatóak');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik igaz a következő állítások közül?', 'Kötelező minden osztályban konstruktort megadni', '@A konstruktor neve meg kell, hogy egyezzen az osztály nevével', 'A konstruktor visszatérési értéke lehet void', 'A konstruktort a példányosítás után is meg lehet hívni');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\npublic class WithName {\r\n  private String name;\r\n\r\n  public WithName(String name) {\r\n    name = name;\r\n  }\r\n\r\n  public String getName() {\r\n    return name;\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    WithName withName = new WithName("Joe");\r\n    System.out.println(withName.getName());\r\n  }\r\n}', 'Nem fordul le', '@null', 'Joe', 'IllegalArgumentException kivétel keletkezik');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\npublic class Incrementer {\r\n  public void inc(int i) {\r\n    i++;\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    int i = 5;\r\n    new Incrementer().inc(i);\r\n    System.out.println(i);\r\n  }\r\n}', '@5', '6', 'Nem fordul le', 'Kivételt dob');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik hamis a Java memóriakezelésével kapcsolatban?', '@Az objektumok a stacken jönnek létre', 'A lokális változók, ha referenciák, a referencia a stacken jön létre, az objektum a heapen', 'A primitív típusú lokális változók a stacken jönnek létre', 'Minden metódushívás kap egy külön területet a stacken, melybe a lokális változók értékei kerülnek');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Hogyan lehet egy szövegben sortörést elhelyezni?', 'Csak System.out.println() használatával', '@String s = "a\\nb";', 'String s = "a\\BRCRb";', 'String s = "a" + \\n + "b";');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik hamis a felsorolásos típusokkal kapcsolatban?', 'A felsorolásos típus elemeihez egy egész szám van rendelve', 'String alapján is lehet a felsorolásos típus egy elemét elkérni', 'switch szerkezetben használható', '@Felsorolásos típusnak nem lehet konstruktora');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik utasítással lehet végigmenni a felsorolásos típus elemein?\r\npublic enum Day {\r\n  FIRST, SECOND\r\n}', 'for (Day day: Day) {}', '@for (Day day: Day.values()) {}', 'for (Day day : Day.items()) {}', 'for (Day day: Day.values) {}');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mi az értéke a következő kifejezésnek?\r\n(3 > 5) || (1/0 == 0)', 'true', 'false', '@java.lang.ArithmeticException hiszen nullával való osztás van', '0');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik kódrészlet nem helyes?', 'int a = 0; int b = 1; int c = a + b;', 'Integer a = 0; Integer b = 1; Integer c = a + b;', '@BigInteger a = new BigInteger(0); BigInteger b = new BigInteger(1); BigInteger c = a + b;', 'String a = "0"; String b = "1"; String c = a + b;');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik értékadás helyes az alábbiak közül?', 'byte b = 300;', 'long k = 10; int i = k;', '@long k = 10; int i = (int) k;', 'long l = 2.5;');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kód?\r\npublic static void main(String[] args) {\r\n  int[] a = {1,2,3,4,5,6};\r\n  int i = a.length - 1;\r\n  while(i>=0){\r\n    System.out.print(a[i]);\r\n    i--;\r\n  }\r\n}', '123456', '@654321', '65432', 'IndexOutOfBoundsException');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kód?\r\npublic static void main(String[] args) {\r\n  for(int i = 0; i <= 5; i++){\r\n    System.out.print(i);\r\n  }\r\n  System.out.print(i);\r\n}', '012345', '0123455', '@Nem fordul le', 'IndexOutOfBoundsException');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kód?\r\nString s = "aaa";\r\nswitch (s) {\r\n  case "bbb":\r\n    System.out.print("3b");\r\n  case "aaa":\r\n    System.out.print("3a");\r\n  case "ccc":\r\n    System.out.print("3c");\r\n}', 'Nem fordul le, hiszen String van a switch feltételben', '3a', '@3a3c', 'Kivétel keletkezik');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mennyivel tér vissza az alábbi metódus, ha a következőképp hívjuk boolean isValid = isValidNumber("5");?\r\npublic boolean isValidNumber(String number) {\r\n  try {\r\n    int value = Integer.parseInt(number);\r\n    if (value < 0 && value > 10) {\r\n      return true;\r\n    }\r\n    return false;\r\n  } catch (NumberFormatException nfe) {\r\n    return false;\r\n  }\r\n}', 'true', '@false', 'NumberFormatException keletkezik a hívás helyén', 'Nem fordul le a kód');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik igaz a kivételkezelésre?', 'Csak beépített kivételeket használhatunk', 'A keletkezett kivételt minden esetben kezelnünk kell a metódusban', '@A kivételt tovább dobhatjuk a hívónak', 'Az összes kivétel unchecked kivétel');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Válaszd ki az igaz állítást!', 'A return utasítás csak a metódus végén lehet.', 'A return utasítás egy metódusban csak egyszer szerepelhet.', 'A void visszatérési típusú metódusnál nem használhatunk return utasítást.', '@A return utasításnak nem kell pontosan olyan típust visszaadni, mint a visszatérési érték, hiszen itt is lehet típuskonverzió.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Az int mérete', '8 bit', '16 bit', '@32 bit', '64 bit');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\nfinal int i;\r\ni = 3;\r\nint[] n = {1, 2, 3};\r\nSystem.out.println(n[i]);', 'Nem lehet final változónak értéket adni.', '@ArrayIndexOutOfBoundsException kivétel', '3', '0');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mi hamis a típuskonverzióval kapcsolatban?', 'Típuskonverzió operátorok alkalmazásakor, paraméterátadáskor, metódus visszatéréskor történhet', '@int típusból Integer típussá alakításkor implicit típuskonverzió van', 'A típuskonverzió értelmezett primitív és referencia típusok esetén is', 'A típuskonverzió implicit, ha nem írjuk ki, explicit ha kiírjuk és kerek zárójeleket alkalmazunk');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\nList<String> names = new ArrayList<>();\r\nnames.add("John Doe");\r\nnames.add("John Doe");\r\nSystem.out.println(names.length);', '1', '@Nincs length attribútuma, csak metódusa, ezért nem fordul le.', '2', 'Nincs length attribútuma, csak metódusa, ezért 0.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Válaszd ki az igaz állítást!', '@A push művelettel lehet a lokális repository-ból a commitokat feljuttatni a távoli repository-ba.', 'A push művelettel lehet a lokális repository-ba a commitokat bejuttatni.', 'A commit adja hozzá a fájlokat a Githez, hogy arról tudjon a verziókezelő, de hogy bekerüljön, még egy plusz műveletet el kell végezni.', 'Ha kitörlünk egy állományt, az automatikusan eltűnik a Git repo-ból, nem kell commit művelet.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mi hamis a lokális változókkal kapcsolatban?', 'A lokális változók nem kapnak kezdőértéket', '@A final kulcsszóval ellátott lokális változónak a deklarálás sorában értéket kell adni (pl. final int i = 5;)', 'A lokális változók a stacken helyezkednek el', 'A nem null értékû referencia típusú lokális változók egy heapen elhelyezkedő objektumra mutatnak');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\nSystem.out.println("apple".substring(2, 4));', '@pl', 'ppl', 'pp', 'ple');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\nString s = null;\r\nSystem.out.println("foo".equals(s));', 'Nem fordul le', 'NullPointerException keletkezik', 'true', '@false');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Válaszd ki az igaz állítást!\r\npublic class Trainer {\r\n  private String name;\r\n  private int yearOfBirth;\r\n\r\n  public Trainer(String name) {\r\n    this.name = name;\r\n    yearOfBirth = 30;\r\n  }\r\n}', 'A name formális paraméter elfedi az attribútumot, így a name valójában nem kap értéket.', 'A yearOfBirth attribútumnak így nem lehet értéket adni.', 'A yearOfBirth attribútum értéke 0 marad, hiszen az az attribútum alapértelmezett értéke.', '@A name értéke a példányosításkor konstruktorban átadott érték lesz, a yearOfBirth értéke 30.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('A következő típuskonverziók közül melyik nem fordul le?', 'byte b = 100;', '@int i = 1.1;', 'double d = 1;', 'int i = (int) 1.1;');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\nint[] n = {1, 2, 3};\r\nfor (int i: n) {\r\n  System.out.println(i);\r\n}', '@Sortöréssel elválasztva: 1 2 3', 'Sortöréssel elválasztva: 0 1 2', 'Sortöréssel elválasztva: 0 0 0', 'Sortöréssel elválasztva: 3 3 3');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mi lesz a következő utasítás eredménye?  double d = 3 + 5 / 2;', 'Fordítási hiba.', 'd értéke 4', '@d értéke 5', 'd értéke 4.5');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Hogyan hasonlítunk össze String értékeket?', 'Mindig az == operátorral.', 'Az attól függ. Bizonyos esetekben a == operátorral.', '@Mindig az equals() metódussal.', 'Csak ha az egyik oldal literál, akkor kell az equals() metódust alkalmazni.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\nint i = 5;\r\nif (i % 2 != 0) {\r\n  String value = "Odd";\r\n}\r\nSystem.out.println(value);', '@Nem fordul le.', 'Odd', 'null', 'Futás közben hibával leáll.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki a következő kódrészlet?\r\nString s = null;\r\ns = "foo";\r\ns.toUpperCase();\r\nSystem.out.println(s);', 'Nem fordul le, mert a második sorban értékadás van, és a String immutable', '@foo', 'FOO', 'Hiba futás közben');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Válaszd ki a hamis állítást!', 'A this kulcsszó az aktuális példányra vonatkozik.', '@Mivel az attribútum elfedheti a formális paramétert, a this kulcsszót kell használni.', 'A formális paraméter elfedheti az attribútumot.', 'A setter metódus feladata egy attribútum értékének beállítása.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\nfor (int i = 3; i >=0; i--) {\r\n  System.out.println(i);\r\n}', '@Sortöréssel elválasztva: 3 2 1 0.', 'Sortöréssel elválasztva: 3 2 1.', 'Sortöréssel elválasztva: 2 1 0.', 'Nem fordul le.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik állítás igaz az alábbiak közül?', 'Java alkalmazások kizárólag fejlsztőeszközzel fejleszthetők.', '@A fejlesztőeszköz is a fordítót és a JVM-et használja.', 'Maven nélkül nem lehet Java projektet létrehozni.', 'A Javaban van standard projektfelépítés, könyvtárszerkezet.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik hamis az alábbi állítások közül?', '@Az importáláskor csillaggal megadva beimportálhatjuk az adott csomagnak és annak összes alcsomagjának osztályát', 'Nem kell importálni a java.lang csomag osztályait', 'Az importálással más csomagban lévő osztályokat lehet használnunk, anélkül, hogy minősítenénk', 'Az importálás helyettesíthető azzal, hogy az osztályt csomagnévvel minősítem');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Hogyan konvertálunk egy egész számot String típusú változóba (int i = 5)?', 'String s = i + "";', 'String s = Integer.toString(i);', 'String s = "" + i;', '@Mindegyik megoldás helyes');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Válaszd ki az igaz állítást!', 'A Maven az alkalmazás forráskódját az src/java/main könyvtárban tartalmazza', 'A Maven koordináták kizárólag a group és ver.', '@Az mvn package paranccsal lehet lefordítani a forráskódot, valamint összecsomagolni a jar állományt.', 'A Maven preferálja, hogy mindent úgy adjunk meg, ahogy mi szeretnénk, azaz egyéni konfigurációkat használjunk.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki a következő kódrészlet?\r\nString s = "2";\r\nswitch (s) {\r\n  case "1":\r\n    System.out.print("one ");\r\n  case "2":\r\n    System.out.print("two ");\r\n  case "3":\r\n    System.out.print("three ");\r\n  default:\r\n    System.out.print("booo ");\r\n}', 'Nem fordul le, mert switch szerkezetnél nem használható String', 'two', '@two three booo', 'two three');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Hogyan hozol létre egy szövegből egész számot? String s = "5";', 'int i = s;', 'int i = (String) s;', 'int i = String.parse(s);', '@int i = Integer.parseInt(s);');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Amennyiben van egy s String típusú változó, hogyan alakítjuk át enum típussá?', '@Weekdays w = Weekdays.valueOf(s);', 'Weekdays w = (Weekdays) s;', 'Weekdays w = new Weekdays(s);', 'Weekdays w = s;');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik állítás hamis az immutable osztályokkal kapcsolatban?', 'Érdemes az attribútumait final kulcsszóval ellátni, hogy csak egyszer lehessen neki értéket adni.', 'Használatuk azért is hasznos, mert paraméterként átadva biztosak lehetünk benne, hogy a hívás során nem változik az értéke.', 'A String osztály immutable', '@A metódusai módosíthatják az attribútumok értékét, csak a paraméterek értékét nem módosíthatják');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik állítás hamis, az alábbi kódrészlet esetén?\r\npublic class TrainerData {\r\n  private String name;\r\n  private List<String> courses;\r\n\r\n  public TrainerData(String name, List<String> courses) {\r\n    this.name = name;\r\n    this.courses = new ArrayList<>(courses);\r\n  }\r\n\r\n  public String getName() {\r\n    return name;\r\n  }\r\n\r\n  public List<String> getCourses() {\r\n    return courses;\r\n  }\r\n}', 'A TrainerData osztály name attribútuma osztályon kívülről módosítható, ugyanis nincs final módosítószóval ellátva', 'A TrainerData immutable, még a courses lista tartalma sem változtatható kívülről', 'A name attribútum módosítható, pl. így: new TrainerData("John Doe", Arrays.asList("Biology")).getName().toUpperCase();', '@Mind a három állítás hamis');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mely igaz a JavaBeans konvenciókkal kapcsolatban?', 'Minden Java osztálynak JavaBeansnek kell lennie', 'Kötelezően lenniük kell getter és setter metódusainak', 'Minden típus esetén ugyanazt az elnevezést kell alkalmaznunk, get prefix, utána az attribútum neve, aminek az első karaktere nagybetű, pl. getName()', '@Attribútum, és a hozzá tartozó metódusok összefoglaló neve property');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\npublic class WithName {\r\n  private String name;\r\n\r\n  public WithName(String name) {\r\n    this.name = name;\r\n  }\r\n\r\n  public void modifyName(String name) {\r\n    return this.name;\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    System.out.println(new WithName("John Doe").modifyName("Jack Doe"));\r\n  }\r\n}', 'John Doe', 'Jack Doe', 'null', '@Nem fordul le');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\npublic class Numbers {\r\n  public String addFive(String s) {\r\n    return s + 5;\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    System.out.println(new Numbers().addFive(10));\r\n  }\r\n}', '105', '15', '@Nem fordul le', 'Futás közben kivételt dob');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\npublic class NameConverter {\r\n  public void convertNames(String name, List<String> otherNames) {\r\n    name = name.toUpperCase();\r\n    for (int i = 0; i < otherNames.size(); i++) {\r\n      otherNames.set(i, otherNames.get(i).toUpperCase());\r\n    }\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    String name = "John Doe";\r\n    List<String> names = new ArrayList<>(Arrays.asList("Jane Doe"));\r\n    new NameConverter().convertNames(name, names);\r\n    System.out.print(name);\r\n    System.out.print(" ");\r\n    System.out.print(names);\r\n  }\r\n}', '@John Doe [JANE DOE]', 'JOHN DOE [JANE DOE]', 'John Doe [Jane Doe]', '[John Doe, Jane Doe]');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\npublic class NameConverter {\r\n  public String convertName(String name) {\r\n    if (name.equals("")) {\r\n      return;\r\n    }\r\n    return name.toUpperCase();\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    System.out.println(new NameConverter().convertName(""));\r\n  }\r\n}', '@Nem fordul le', 'Üres string, azaz ""', 'null', 'Futás közben hiba keletkezik');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik a helytelen módja a paraméterek bejárásának, a következő kódrészlet esetén:\r\npublic List<Course> createCourses(String... names) {\r\n  List<Course> courses = new ArrayList<>();\r\n  // Bejárás\r\n}', 'for (String name: names) { courses.add(new Course(name)); }', '@for (int i = 0; i< names.length; i++) { courses.add(new Course(names.get(i))); }', 'for (int i = 0; i< names.length; i++) { courses.add(new Course(names[i])); }', 'Egyik megadási mód sem helyes');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\npublic class Builder {\r\n  private String name;\r\n\r\n  public Builder setName(String name) {\r\n    this.name = name;\r\n    return this;\r\n  }\r\n\r\n  public String build() {\r\n    return name;\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    System.out.print(new Builder().build());\r\n    System.out.print(" ");\r\n    System.out.print(new Builder().setName("John Doe").setName("Jack Doe").build());\r\n  }\r\n}', 'Nem fordul le', '@null Jack Doe', 'Jack Doe', 'null John Doe');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik metódussal lehet túlterhelni (overload) a következő metódust?\r\npublic Course createCourse(String name) {}', 'public Course create(String name) {}', 'public SpecificCourse createCourse(String name) {}', '@public Course createCourse(String name, Level level) {}', 'public Course createCourse(String name) {}');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('A main metódusból hogyan lehet meghívni a convert metódust, az alábbi kódrészletben?\r\npublic class Concatenator {\r\n  public static String convert(int a, int b) {\r\n    return Integer.toString(a) + Integer.toString(b);\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    // ???\r\n  }\r\n}', 'Csak a Concatenator.convert(5, 6); utasítással', 'Csak a convert(5, 6); utasítással', 'Csak a new Concatenator().convert(5, 6); utasítással', '@Mindhárom utasítással, de nem mindegyik javasolt');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\npublic class State {\r\n  private static int instance = 0;\r\n\r\n  public State() {\r\n    instance ++;\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    new State();\r\n    new State();\r\n    System.out.println(instance);\r\n  }\r\n}', 'Nem fordul le', '0', '1', '@2');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet, ha feltételezzük, hogy a két osztály két külön .java fájlban van deklarálva, a megfelelő könyvtárakban.\r\npackage foo;\r\npublic class Foo {\r\n  public static int value = 10;\r\n}\r\n\r\npackage bar;\r\nimport static foo.Foo;\r\npublic class Bar {\r\n  public static void main(String[] args) {\r\n    System.out.println(value);\r\n  }\r\n}', '@Nem fordul le', '10', '0', 'Futás közben hiba');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik állítás hamis a következő kódrészletre?\r\npublic class Trainer {\r\n  private String name;\r\n\r\n  public Trainer(String name) {\r\n    this.name = name;\r\n  }\r\n}', '@Az osztály példányosítható a következő módon: Trainer t = new Trainer();', 'Az osztály példányosítható a következő módon: Trainer t = new Trainer("Anonymous");', 'Az osztály példányosítható a következő módon: Trainer t = new Trainer(null);', 'Nem kerül legenerálásra paraméter nélküli implicit konstruktor, hiszen van explicit konstruktor');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik konstruktor nem illeszhető be ebbe az osztályba harmadik konstruktorként?\r\npublic class Trainer {\r\n  private String name;\r\n  private int age;\r\n\r\n  public Trainer(String name) {\r\n    this(name, 0);\r\n  }\r\n\r\n  public Trainer(String name, int age) {\r\n    this.name = name;\r\n    this.age = age;\r\n  }\r\n}', 'public Trainer() {this(null, 0);}', 'public Trainer() {super();}', '@public Trainer() {String name = "anonymous"; this(name);}', 'public Trainer(int age) { this(null, age); }');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\nclass A {\r\n  String s = "-";\r\n  protected A() { this("d"); s += "a"; }\r\n  private A(String e) { s += "d"; }\r\n}\r\n\r\nclass B extends A {\r\n  B() { super(); s += "b"; }\r\n}\r\n\r\nclass C extends B {\r\n  C() { s += "c"; }\r\n  public static void main(String... boo) {\r\n    System.out.println((new C()).s);\r\n  }\r\n}', '@-dabc', '-abc', '-adbc', '-cba');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mely állítás igaz az implicit (default) konstruktorral kapcsolatban?', 'Fogadhat paramétereket', 'private módosítószóval rendelkezik', 'Amennyiben definiálunk egy paraméteres konstruktort, az implicit (default) konstruktor továbbra is hívható', '@Törzsében szerepel egy super() hívás');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet?\r\nclass Ex1 {\r\n  public static void main(String[] args) {\r\n    int a[] = { 1,2,3,4}; // 1\r\n    System.out.print(a instanceof Object); // 2\r\n  }\r\n}', '@true', 'false', 'Nem fordul le az egyessel jelölt sor', 'Nem fordul le a kettessel jelölt sor');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik állítás hamis a Human osztály leszármazottjára (extends), a következő kódrészlet esetén:\r\npublic class Human {\r\n  private String name;\r\n}', 'Leszármazottban elérhető a name attribútum, ha a Human osztályban protected láthatósági módosítóval látjuk el', 'Definiáljunk egy publikus gettert az attribútumnak, és akkor a leszármazottban is hozzá lehet férni a getterrel', '@A super.name hívással is hozzá lehet férni a leszármazottban', 'A protected módosítószó a package private kiterjesztése, használatakor nem csak az azonos csomagban lévő osztályok, hanem bármely leszármazott eléri az adott tagot');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit kell a megjegyzés helyére írni, hogy a következő kódrészlet 12-t írjon ki?\r\nclass Mid {\r\n  public int findMid(int n1, int n2) {\r\n    return (n1 + n2) / 2;\r\n  }\r\n}\r\n\r\npublic class Calc extends Mid {\r\n  public static void main(String[] args) {\r\n    int n1 = 22, n2 = 2;\r\n    // Egészítsd ki\r\n    System.out.println(n3);\r\n  }\r\n}', '@Calc c = new Calc(); int n3 = c.findMid(n1,n2);', 'int n3 = super.findMid(n1,n2);', 'Calc c = new Mid(); int n3 = c.findMid(n1, n2);', 'int n3 = this.findMid(n1,n2);');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik sor nem illeszthető a hiányzó kód helyére, az alábbi kódrészletben?\r\nclass Plant {\r\n  String getName() { return "plant"; }\r\n  Plant getType() { return this; }\r\n}\r\n\r\nclass Flower extends Plant {\r\n  // Hiányzó kód\r\n}\r\n\r\nclass Tulip extends Plant { }', 'Tulip getType() { return new Tulip(); }', 'Plant getType() { return this; }', '@Object getType() { return this; }', 'Flower getType() { return this; }');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mely deklaráció fordul le?', 'public abstract class Canine { public void speak(); }', 'public class Canine abstract { public abstract void speak(); }', 'public class Canine { public abstract void speak(); }', '@public abstract class Canine { public void speak(){} }');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Adottak a következő állítások. Az A és E osztály. A B és D interfész. A C absztrakt osztály.\r\nMelyik helytelen a következő megadások közül?', 'class F implements B { }', '@class F extends A, E { }', 'class F extends E { }', 'class F implements B,D { }');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Adottak a következő kódrészletek. Melyik kódrészlet folytatás helytelen?\r\nabstract class X {\r\n  public abstract void methodX();\r\n}\r\n\r\ninterface Y {\r\n}', '@class Z extends X implements Y { public void methodZ(); }', 'abstract class Z extends X implements Y { public void methodZ() {} }', 'class Z extends X implements Y { public void methodX() {} }', 'abstract class Z extends X implements Y { }');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik helyes deklaráció interfészen belül?', '@public void doMore(long bow);', 'public void doMore(long bow) {}', 'private short hop = 23;', 'public Name();');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik írja ki a konzolra azt, hogy Hello World?', '@System.out.println("Hello World")', 'print("Hello World")', 'System.console.print("Hello World")', 'println("Hello World")');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik nem primitív típus?', '@String', 'int', 'char', 'double');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik Collection implementációt célszerű választanunk, ha gyakran kell elemeket hozzáadni vagy eltávolítani, azonban ritkábban index szerinti elérésre is szükség lehet, és egy elemet lehet, hogy többször is fel akarunk venni?', '@LinkedList', 'HashMap', 'HashSet', 'ArrayList');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mi a különbség az Exception és az Error közt?', '@Az Exception olyan szituációt reprezentál, ami "megoldható", míg az Error általában olyan hibát jelent, ami után nem folytatható a program futása.', 'Az Error olyan szituációt reprezentál, ami "megoldható", míg az Exception általában olyan hibát jelent, ami után nem folytatható a program futása.', 'Az Error nem a Throwable osztályból származik, míg az Exception igen.', 'Az Exception nem a Throwable osztályból származik, míg az Error igen.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Ha String word = "papaya", akkor melyik kifejezés adja vissza az utolsó p betű helyét?', '@word.lastIndexOf("p")', 'word.indexOf("p")', 'lastIndexOf(word, p)', 'word.charAt(2)');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Létre akarok hozni egy Object típusú példányt, és elmenteni őt egy Object típusú változóba, hogyan tudom ezt megtenni?', '@Object object = new Object();', 'Object object = Object();', 'Object object = new Object;', 'Object = new Object();');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik dolog nem szerepel egy UML diagramon?', '@Lokális változók', 'Interface implementálása', 'A példányváltozók láthatósága', 'A metódusok visszatérési értéke');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mely állítás hamis az alábbiak közül a következő kódrészlettel kapcsolatban?\r\npublic class Trainer {\r\n  private String name;\r\n\r\n  public Trainer(String name) {\r\n    this.name = name;\r\n  }\r\n}', '@Az osztály példányosítható (instantiate) a következő módon: Trainer t = new Trainer();', 'Az osztály példányosítható (instantiate) a következő módon: Trainer t = new Trainer("Anonymous");', 'Az osztály példányosítható (instantiate) a következő módon: Trainer t = new Trainer(null);', 'Nem kerül legenerálásra paraméter nélküli implicit (default) konstruktor, hiszen van explicit konstruktor');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Válaszd ki az igaz állítást!', 'Az osztályok tagjai kizárólag az attribútumok (fields), metódusok és getter/setterek.', 'Az attribútumok (fields) speciális metódusok.', '@A konstruktorok felelősek az objektum állapotának inicializálásáért.', 'A metódusok tárolják az attribútumok (fields) értékeit.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Egy korábbi sorban már létrehozott Object object változóm értékét szeretném felülírni egy új Object példánnyal, hogyan tudom ezt megtenni?', '@object = new Object();', 'Object object = new Object();', 'object = Object();', 'object = new object();');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Hogyan dobható Exception kézzel?', '@throw new MyException();', 'throw MyException;', 'throws new MyException();', 'throws myException;');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik kulcsszóval hivatkozhatunk egy objektumon belül saját magára?', '@this', 'instance', 'that', 'super');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi Java kód?\r\npublic class Test {\r\n  public void doSomething() {\r\n    throw new RuntimeException();\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    try {\r\n      new Test().doSomething();\r\n    }\r\n    catch (Throwable t) {\r\n    System.out.println("Yupp");\r\n    }\r\n  }\r\n}', 'Nem fordul le, mert a doSomething() metódus nem definiálja a fejben (method header) a RuntimeException kivételt (exception)', '@Yupp', 'Az alkalmazás leáll, mert nem kezelt kivétel (unchecked exception) keletkezik', 'Nem ír ki semmit, az alkalmazás hiba nélkül lefut');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Az alábbiak közül melyik igaz az absztrakt osztályokra?', '@Származhatnak egy másik absztrakt osztályból.', 'Nem lehetnek példányváltozóik.', 'Absztrakt osztályból való leszármazáshoz az implements kulcsszót használjuk.', 'Csak absztrakt metódusokat tartalmazhatnak.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik primitív típus?', '@double', 'Dog', 'Object', 'String');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Válaszd ki a Building osztály House alosztályának megfelelő definiálását!', '@public class House extends Building {}', 'public subclass House extends Building {}', 'public class House subclass of Building {}', 'public class Building.House {}');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Ha String word = "banana", akkor melyik kifejezés adja vissza az első a betű helyét?', '@word.indexOf("a")', 'word.charAt(2)', 'word.lastIndexOf("a")', 'indexOf(word, "a")');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik metódussal NEM lehet egy booleant visszaadó metódus visszatérési értékét tesztelni?', '@assertThrows', 'assertTrue', 'assertEquals', 'assertFalse');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik érvényes Java kulcsszó?', '@new', 'main', 'function', 'Int');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik írja ki a konzolra a String msg változó értékét?', '@System.out.println(msg)', 'System.console.write(msg)', 'msg.toString()', 'System.print("msg")');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik deklaráció írja le, hogy a metódus NullPointerException és IOException kivételt is dobbat?', 'public void print() throw NullPointerException | IOException', 'public void print() throws NullPointerException | IOException', 'public void print() throw NullPointerException throw IOException', '@public void print() throws NullPointerException, IOException');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Miért okoz fordítási hibát az alábbi kódrészlet?\r\nList<HashMap<Queue<Boolean>, ArrayList<Set<double>>>> mess;', 'A List interfész, helyette valamilyen azt implementáló osztályt kell megadni', 'A kódrészlet nem okoz fordítási hibát', 'Kollekciókat nem lehet ilyen mélyen egymásba ágyazni', '@Nem lehet primitív típust megadni típusparaméternek');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki az alábbi kódrészlet? \r\nString s = "dog";\r\ns.toUppercase();\r\nSystem.out.println(s);', 'Üres sztringet', 'Nem fordul le', 'DOG', '@dog');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Hogyan hozható létre egy oszály új példánya?', 'A class kulcsszóval', 'Egy új fájl létrehozásával', 'A konstruktor meghívásával', '@A new kulcsszó segítségével');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki?\r\npublic class Main {\r\n  public static void main (String[] args) {\r\n    Map<String, String> someMap = new HashMap<>();\r\n    someMap.put("someKey","someValue");\r\n    someMap.put("someKey","someOtherValue");\r\n    System.out.print1n(someMap.size() + someMap.get("someKey"));\r\n  }\r\n}', 'Futásidőben exception keletkezik, mivel a someKey kulcs már szerepel a mapben, ezért nem lehet újra felvenni.', '2someOtherValue', '@1someOtherValue', '1someValue');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Az alábbiak közül melyik nem implementálja a Collection interfacet-t?', '@Enum', 'HashSet', 'ArrayList', 'LinkedList');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Adott a következő kódrészlet. Melyik sort kell beilleszteni a komment helyére, hogy true értéket írjon ki?\r\npublic class Bird extends Animal implements CanFly {}\r\n\r\npublic interface CanFly {}\r\n\r\npublic abstract class Animal {}\r\n\r\npublic class AnimalService {\r\n  public static void main(String[] args) {\r\n    Bird bird = new Bird();\r\n    // \r\n  }\r\n}', 'System.out.print(bird.instanceof(CanFly.class))', '@System.out.print(bird instanceof CanFly)', 'System.out.print(bird instanceof CanFly.class)', 'System.out.print(bird.instanceof(Animal))');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Az alábiak közül melyik követi az enum értékek felsorolásának konvencióját?', 'Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday', 'monday, tuesday, wednesday, thursday, friday, saturday, sunday', '"MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"', '@MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mi a különbség a checked és az unchecked exception között?', 'Ha saját exceptiont írunk, az csak checked exception lehet, unchecked nem.', 'A catch blokk nem kapja el az unchecked exceptiont, hiszen ez jellemzően rendszerhiba.', '@A checked exceptionnél a program fordításakor ellenőrzi a compiler, hogy felkészültünk-e rá, és ha nem, akkor fordítási hibát kapunk.', 'Unchecked exception esetén a try-catch-finally-nél a finally ág nem hajtódik végre.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik nem igaz az absztrakt osztályokra?', 'Lehetnek példányváltozóik.', 'Nem példányosíthatók.', '@Csak absztrakt metódusaik lehetnek.', 'Lehetnek absztrakt metódusaik.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mi az a scope?', '@Változók hatóköre.', 'Referencia egy objektumra.', 'Függvény visszatérési értéke.', 'Függvény bemenő paramétere.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Az alábbiak közül melyik nem ciklus?', '@switch', 'while', 'for', 'do-while');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mi az enum?', '@Egy típus, előre felsorolt konstansok tárolására.', 'Memória címek felsorolása.', 'A hét napjainak felsorolása.', 'Egy típus, előre felsorolt változók tárolására.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mit ír ki a következő kód?\r\npublic class TestException {\r\n  public void throwException() {\r\n    System.out.print("throwex ");\r\n    throw new RunTimeException();\r\n  }\r\n\r\npublic static void main(String[] args) {\r\n  try {\r\n    System.out.print("try");\r\n    new TestException().throwException();\r\n  } catch (Exception re) {\r\n    System.out.print("catch ");\r\n  } finally {\r\n    System.out.print("finally ");\r\n  }\r\n  System.out.println("done");\r\n}', 'try throwex catch done', 'try throwex finally done', '@try throwex catch finally done', 'Futási idejű hibával megáll a program futása.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik Collectionre nem igaz, hogy a benne levő elemeket ki tudom venni a hozzáadás sorrendjében?', 'LinkedList', 'ArrayDeque', '@HashSet', 'LinkedHashSet');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Mi az a konstruktor?', 'Új példány létrehozása', 'Új osztály létrehozása', '@A konstruktor hasonlít egy metódusra, amely automatikusan lefut új példány létrehozásakor.', 'Egy változó');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Milyen metódusa nincs a Collection interfésznek?', '@get(K key)', 'size()', 'add(E element)', 'iterator()');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik állítás igaz?', 'Egy interfész tartalmazhat nem final változókat.', 'Egy osztály csak egy interfészt implementálhat.', '@Egy absztrakt osztály tartalmazhat nem final változókat.', 'Az extends kulcsszóval jelöljük, ha egy osztály megvalósít interfészt.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik módosító nem alkalmazható az interfészekben definiált változókon?', 'public', 'final', 'static', '@abstract');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Válaszd ki az igaz állítást!', 'A private módosítószóval ellátott tagok az adott csomagban látszanak.', 'A láthatósági módosítószóval el nem látott tagok mindenütt látszódnak.', 'A public módosítószóval ellátott tagok csak az adott csomagban és leszármazottjaiban látszanak.', '@Az attribútumokat private láthatósággal vegyük fel, így csak az adott osztályon belül látszódnak.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Válaszd ki az igaz állítást!', 'Az összes csomag automatikusan importálásra kerül.', 'A Scanner automatikusan importálásra kerül.', 'A String osztályt importálni kell ahhoz, hogy használhassuk', '@A java.lang csomag automatikusan importálásra kerül.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Válaszd ki az igaz állítást!', '@Az osztály egy modell, és ez alapján több példány hozható létre.', 'Egy osztályból egy példány hozható létre.', 'A példányosítás során mindig új osztály születik.', 'Egy objektumból több példány példányosítható.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Válaszd ki a következő programrészletre igaz állítást!\r\nList<int> numbers = new ArrayList<>();\r\nnumbers.add(0);\r\nnumbers.add(1);\r\nnumbers.add(2);', '@Nem lehet primitív típussal listát létrehozni.', 'Autoboxing történik.', 'Autoboxing nélkül is működik, a lista hossza 3.', 'Mind a két oldalt a List szónak kell állnia a példányosítás miatt.');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik kulcsszó jelöl ciklust?', '@while', 'if', 'switch', 'return');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik nem a kivétel kezeléshez kapcsolódó kulcsszó?', '@final', 'try', 'catch', 'throws');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik primitív típus?', '@char', 'Integer', 'String', 'Boolean[]');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Hogy hívjuk azt, amikor az programunk alapegységeit teszteljük?', '@Unit test', 'Regression test', 'Integration test', 'End-to-end test');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Az alábbiak közül melyik állítás igaz?', '@Több elemet egyszerre törölni a List names-ből a names.removeAll(namesToRemove); metódussal lehet, ahol a namesToRemove a törlendő elemek listája.', 'Az ArrayList hátterében tömb van, ezért a tömbökhöz hasonlóan előre meg kell adni a méretét létrehozáskor.', 'Az List names legelső elemét a names.get(1); metódussal lehet elkérni.', 'Bármilyen típusú érték kerülhet egy ArrayList-be, például: ArrayList<int> integers = new ArrayList<>();');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Milyen operációs rendszeren lehet Java alkalmazást futtatni?', '@Mindegyiken, a Java alkalmazásokat az egyes platformokra elkészített Java Virtuális Gépek (JVM) futtatják, emiatt platformfüggetlen', 'A Java kifejezetten a Microsoft Windows operációs rendszerhez készült programozási nyelv', 'A Java egy open-source programozási nyelv, ezért Linuxra készíthetünk vele programokat', 'A Java az Apple terméke, MacOS és IOS alkalmazásokat készíthetünk vele');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik változónév helyes a Clean Code alapelvek szerint?', '@firstName', 'cc', 'last_name', 'FirstName');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Melyik állítás hamis az alábbiak közül?', 'Az Integer.MAX_VALUE statikus változó tárolja az Integer típusú változók legnagyobb lehetséges értékét', '@Véletlenszámot a Random.nextInt(100) metódushívás ad vissza', 'A PI értékét a Math.PI konstans tárolja', 'Két szám közül a nagyobbat a következő hívás adja vissza: Math.max(a, b)');
INSERT INTO `questions` (`question`, `answer1`, `answer2`, `answer3`, `answer4`) VALUES ('Milyen metódusokat lehet meghívni a list változón, ha a következőképpen definiáljuk?\r\nList<SomeClass> list = new ArrayLst<>();', 'Csak az Object osztály metódusait.', '@Csak a List interfész metódusait', 'Csak az ArrayList osztály metódusait.', 'Csak a Collection interfész metódusait.');
