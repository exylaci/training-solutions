Melyik állítás hamis az alábbiak közül?
A szemétgyűjtő mechanizmust a virtuális gép biztosítja.
A lefordított bájtkód platform független.
Az Oracle szállítja a JDK-t, mely a JRE és olyan (főleg) parancssori fejlesztőeszközök, mint a fordító. A JRE-nek része a virtuális gép és az osztálykönyvtár.
@A virtuális gép elemzi a forráskódot, és soronként futtatja.

Melyik állítás hamis az alábbiak közül?
Java-ban nincs standard projektstruktúra
A Maven alapelve a convention over configuration
@Az IDE nem tud Maven nélkül működni
A Maven parancssorból indítható, nem szükséges fejlesztőeszköz a használatához

Melyik könyvtárba kell elhelyezni a fájlokat Maven esetén? A megadott könyvtárnevek mindig a projekt főkönyvtárától értelmezendők.
@Az src/main/java könyvtárba kell elhelyezni a Java forrásfájlokat és az src/test/java könyvtárba a teszteseteket
A main könyvtárba kell elhelyezni a Java forrásfájlokat és a test könyvtárba a teszteseteket
A main/src/java könyvtárba kell elhelyezni a Java forrásfájlokat és a test/src/java könyvtárba a teszteseteket
A java könyvtárba kell elhelyezni a Java forrásfájlokat és a java/test könyvtárba a teszteseteket

Mi azonosítja a Maven projektet (koordináták)?
A projekt neve
A projekt csomagneve és neve
A projekt groupId, artifactId tulajdonsága
@A projekt groupId, artifactId és version tulajdonsága

Melyik állítás igaz?
@Nem érdemes a forrásállományokat csomagokon kívül elhelyezni
Ha az A osztályból el akarjuk érni egy másik csomagban lévő B osztályt, akkor csak importálással tudjuk azt elérni
A csomag neve és a könyvtár neve eltérhet
Az A osztályból csak akkor használható a B osztály, ha beimportáljuk

Melyik csomag osztályai kerülnek automatikusan importálására, így azokat használhatjuk import nélkül is?
Nincs ilyen csomag, mindig importálni kell
@A java.lang csomag automatikusan importálásra kerül
A String csomag automatikusan importálásra kerül
A common csomag automatikusan importálásra kerül

Melyik hamis a következő állítások közül?
Az osztály fő építőelemei a konstruktorok, metódusok és attribútumok
@Konstruktor megadása kötelező
A getterek és setterek metódusok
Az osztály publikus metódusai adják annak interfészét (attribútumokat ne tegyük publikusra)

Melyik helyes main() deklaráció?
public static int main(String[] args)
public final int main(String args)
public final void main(String args[])
@public static void main(String[] args)

Melyik hamis a kódolási konvenciókkal kapcsolatban?
Változónevek első karaktere, ha betű, kisbetű legyen
Metódusnevek első karaktere, ha betű, kisbetű legyen
@Osztálynevek első karaktere, ha betű, kisbetű legyen
A konstans értékek nevei csupa nagybetűvel és a szavak között aláhúzás karakterrel szerepeljenek

Melyik igaz az alábbi állítások közül?
Egész literálok megadása csak tizes számrendszerben történhet
Változót a következőképpen deklarálunk: let a = 0;
Változót a következőképpen deklarálunk: var a = 0;
@Változót a következőképpen deklarálunk: int a = 0;

Melyik helyes definíció, amennyiben csak a beépített osztálykönyvtárat használjuk?
Int i = 0;
@int i = 0;
arraylist names = new List
char c = null;

Mely állítás igaz a String osztályra?
Hosszát a size() metódussal lehet lekérni
@Állapota nem módosítható
A toUpperCase() metódus az objektum állapotát módosítja úgy, hogy a kisbetűket nagybetűkre cseréli
Értéke nem lehet null

Válaszd ki, hogy melyik értékadás a helyes!
String s = 5;
String s = '5';
@String s = "";
String s = (String) 5;

Melyik kód megfelelő Java String-ek összehasonlítására?
s1 = s2
s1 == s2
@s1.equals(s2)
Mindhárom

Mit ír ki az alábbi kódrészlet?##String s = "dog";##s.toUpperCase();##System.out.println(s);
@dog
DOG
Nem fordul le
Üres sztringet

Melyik utasítással lehet egy ötelemű tömböt definiálni?
@int[] x = {0, 1, 2, 3, 4};
int[4] x;
int array[] = int{5};
int array[5] = new int[];

Mit ír ki az alábbi kódrészlet?##int[] i = {1, 2, 3, 4};##System.out.println(i[4]);
Nem fordul le
0
4
@IndexOutOfBoundsException kivétel keletkezik

Mit ír ki az alábbi kódrészlet?##int[][] i = new int[3][3];##System.out.println(i[2][2]);
Nem fordul le
@0
2
IndexOutOfBoundsException kivétel keletkezik

Milyen módon lehet egy listát feltölteni elemekkel?
List names = {"Joe", "John"};
@List names = Arrays.asList("Joe", "John");
List names = new List;
List names = new ArrayList;

Melyik állítás hamis a következők közül?
A következő utasítás egy üres listát hoz létre: List names = new ArrayList();
@A lista elemeit a következőképp adhatjuk meg: List names = {"Joe", "Jane"};
A lista mérete a size() metódussal kérdezhető le
A listába új elemeket lehet hozzáadni, és elemeket lehet törölni

Melyik hamis a következő állítások közül?
A tömb mérete a következőképp kérdezhető le: names.length
A String hossza a következőképp kérdezhető le: name.length()
@Egy lista mérete a következőképp kérdezhető le: names.length()
A tömb és a lista indexelése nullától kezdődik

Melyik állítás igaz a következők közül?
A tömb második eleméhez hozzáférhetünk a következő módon: names.get(1)
A lista harmadik eleméhez hozzáférhetünk a következő módon: names.get(3)
@A lista kiírása esetén (System.out.println) a lista elemei vesszővel elválasztva kerülnek kiírásra (toString metódus tehát helyesen implementált)
A tömb contains() metódusával lehet megnézni, hogy egy elem szerepel-e a tömbben

Hogyan járjuk be egy lista elemeit?
@for (String s: list) {System.out.println(s);}
for (String s in list) {System.out.println(s);}
for each (String s: list) {System.out.println(s);}
for (int i = 0; i<list.length() ; i++) {System.out.println(list.get(i));}

Mely állítás igaz a következők közül?
Ha final kulcsszóval deklarálunk egy lokális változót, akkor annak a deklarációkor értéket kell adni
Ha final kulcsszóval deklarálunk egy lokális változót, akkor bármikor adhatunk neki értéket a metóduson belül
@Ha final kulcsszóval deklarálunk egy lokális változót, akkor az első használat előtt adnunk kell neki értéket
Ha final kulcsszóval deklarálunk egy lokális változót, akkor int típus esetén az értéke mindig 0

Mit ír ki az alábbi kódrészlet?##public class Incrementer {##  public int inc(int i) {##    return i + 1;##  }####  public static void main(String[] args) {##    int i = 5;##    System.out.println(inc(i));##  }##}
@Nem fordul le
5
6
Kivételt dob

Melyik hamis az alábbiak közül az attribútumokra vonatkozóan?
Az attribútumok kezdőértékkel rendelkeznek, pl.egész számok esetén ez 0
@A lokális változók kezdőértékkel rendelkeznek, pl. egész számok esetén ez 0
Deklaráljuk az attribútumokat private módosítószóval, és csak metódusokon (pl. getter és setter) keresztül férjünk hozzá
Attribútumok értékei pl. konstruktorban is inicializálhatóak

Melyik igaz a következő állítások közül?
Kötelező minden osztályban konstruktort megadni
@A konstruktor neve meg kell, hogy egyezzen az osztály nevével
A konstruktor visszatérési értéke lehet void
A konstruktort a példányosítás után is meg lehet hívni

Mit ír ki az alábbi kódrészlet?##public class WithName {##  private String name;####  public WithName(String name) {##    name = name;##  }####  public String getName() {##    return name;##  }####  public static void main(String[] args) {##    WithName withName = new WithName("Joe");##    System.out.println(withName.getName());##  }##}
Nem fordul le
@null
Joe
IllegalArgumentException kivétel keletkezik

Mit ír ki az alábbi kódrészlet?##public class Incrementer {##  public void inc(int i) {##    i++;##  }####  public static void main(String[] args) {##    int i = 5;##    new Incrementer().inc(i);##    System.out.println(i);##  }##}
@5
6
Nem fordul le
Kivételt dob

Melyik hamis a Java memóriakezelésével kapcsolatban?
@Az objektumok a stacken jönnek létre
A lokális változók, ha referenciák, a referencia a stacken jön létre, az objektum a heapen
A primitív típusú lokális változók a stacken jönnek létre
Minden metódushívás kap egy külön területet a stacken, melybe a lokális változók értékei kerülnek

Hogyan lehet egy szövegben sortörést elhelyezni?
Csak System.out.println() használatával
@String s = "a\nb";
String s = "a\BRCRb";
String s = "a" + \n + "b";

Melyik hamis a felsorolásos típusokkal kapcsolatban?
A felsorolásos típus elemeihez egy egész szám van rendelve
String alapján is lehet a felsorolásos típus egy elemét elkérni
switch szerkezetben használható
@Felsorolásos típusnak nem lehet konstruktora

Melyik utasítással lehet végigmenni a felsorolásos típus elemein?##public enum Day {##  FIRST, SECOND##}
for (Day day: Day) {}
@for (Day day: Day.values()) {}
for (Day day : Day.items()) {}
for (Day day: Day.values) {}

Mi az értéke a következő kifejezésnek?##(3 > 5) || (1/0 == 0)
true
false
@java.lang.ArithmeticException hiszen nullával való osztás van
0

Melyik kódrészlet nem helyes?
int a = 0; int b = 1; int c = a + b;
Integer a = 0; Integer b = 1; Integer c = a + b;
@BigInteger a = new BigInteger(0); BigInteger b = new BigInteger(1); BigInteger c = a + b;
String a = "0"; String b = "1"; String c = a + b;

Melyik értékadás helyes az alábbiak közül?
byte b = 300;
long k = 10; int i = k;
@long k = 10; int i = (int) k;
long l = 2.5;

Mit ír ki az alábbi kód?##public static void main(String[] args) {##  int[] a = {1,2,3,4,5,6};##  int i = a.length - 1;##  while(i>=0){##    System.out.print(a[i]);##    i--;##  }##}
123456
@654321
65432
IndexOutOfBoundsException

Mit ír ki az alábbi kód?##public static void main(String[] args) {##  for(int i = 0; i <= 5; i++){##    System.out.print(i);##  }##  System.out.print(i);##}
012345
0123455
@Nem fordul le
IndexOutOfBoundsException

Mit ír ki az alábbi kód?##String s = "aaa";##switch (s) {##  case "bbb":##    System.out.print("3b");##  case "aaa":##    System.out.print("3a");##  case "ccc":##    System.out.print("3c");##}
Nem fordul le, hiszen String van a switch feltételben
3a
@3a3c
Kivétel keletkezik

Mennyivel tér vissza az alábbi metódus, ha a következőképp hívjuk boolean isValid = isValidNumber("5");?##public boolean isValidNumber(String number) {##  try {##    int value = Integer.parseInt(number);##    if (value < 0 && value > 10) {##      return true;##    }##    return false;##  } catch (NumberFormatException nfe) {##    return false;##  }##}
true
@false
NumberFormatException keletkezik a hívás helyén
Nem fordul le a kód

Melyik igaz a kivételkezelésre?
Csak beépített kivételeket használhatunk
A keletkezett kivételt minden esetben kezelnünk kell a metódusban
@A kivételt tovább dobhatjuk a hívónak
Az összes kivétel unchecked kivétel

Válaszd ki az igaz állítást!
A return utasítás csak a metódus végén lehet.
A return utasítás egy metódusban csak egyszer szerepelhet.
A void visszatérési típusú metódusnál nem használhatunk return utasítást.
@A return utasításnak nem kell pontosan olyan típust visszaadni, mint a visszatérési érték, hiszen itt is lehet típuskonverzió.

Az int mérete
8 bit
16 bit
@32 bit
64 bit

Mit ír ki az alábbi kódrészlet?##final int i;##i = 3;##int[] n = {1, 2, 3};##System.out.println(n[i]);
Nem lehet final változónak értéket adni.
@ArrayIndexOutOfBoundsException kivétel
3
0

Mi hamis a típuskonverzióval kapcsolatban?
Típuskonverzió operátorok alkalmazásakor, paraméterátadáskor, metódus visszatéréskor történhet
@int típusból Integer típussá alakításkor implicit típuskonverzió van
A típuskonverzió értelmezett primitív és referencia típusok esetén is
A típuskonverzió implicit, ha nem írjuk ki, explicit ha kiírjuk és kerek zárójeleket alkalmazunk

Mit ír ki az alábbi kódrészlet?##List<String> names = new ArrayList<>();##names.add("John Doe");##names.add("John Doe");##System.out.println(names.length);
1
@Nincs length attribútuma, csak metódusa, ezért nem fordul le.
2
Nincs length attribútuma, csak metódusa, ezért 0.

Válaszd ki az igaz állítást!
@A push művelettel lehet a lokális repository-ból a commitokat feljuttatni a távoli repository-ba.
A push művelettel lehet a lokális repository-ba a commitokat bejuttatni.
A commit adja hozzá a fájlokat a Githez, hogy arról tudjon a verziókezelő, de hogy bekerüljön, még egy plusz műveletet el kell végezni.
Ha kitörlünk egy állományt, az automatikusan eltűnik a Git repo-ból, nem kell commit művelet.

Mi hamis a lokális változókkal kapcsolatban?
A lokális változók nem kapnak kezdőértéket
@A final kulcsszóval ellátott lokális változónak a deklarálás sorában értéket kell adni (pl. final int i = 5;)
A lokális változók a stacken helyezkednek el
A nem null értékû referencia típusú lokális változók egy heapen elhelyezkedő objektumra mutatnak

Mit ír ki az alábbi kódrészlet?##System.out.println("apple".substring(2, 4));
@pl
ppl
pp
ple

Mit ír ki az alábbi kódrészlet?##String s = null;##System.out.println("foo".equals(s));
Nem fordul le
NullPointerException keletkezik
true
@false

Válaszd ki az igaz állítást!##public class Trainer {##  private String name;##  private int yearOfBirth;####  public Trainer(String name) {##    this.name = name;##    yearOfBirth = 30;##  }##}
A name formális paraméter elfedi az attribútumot, így a name valójában nem kap értéket.
A yearOfBirth attribútumnak így nem lehet értéket adni.
A yearOfBirth attribútum értéke 0 marad, hiszen az az attribútum alapértelmezett értéke.
@A name értéke a példányosításkor konstruktorban átadott érték lesz, a yearOfBirth értéke 30.

A következő típuskonverziók közül melyik nem fordul le?
byte b = 100;
@int i = 1.1;
double d = 1;
int i = (int) 1.1;

Mit ír ki az alábbi kódrészlet?##int[] n = {1, 2, 3};##for (int i: n) {##  System.out.println(i);##}
@Sortöréssel elválasztva: 1 2 3
Sortöréssel elválasztva: 0 1 2
Sortöréssel elválasztva: 0 0 0
Sortöréssel elválasztva: 3 3 3

Mi lesz a következő utasítás eredménye?  double d = 3 + 5 / 2;
Fordítási hiba.
d értéke 4
@d értéke 5
d értéke 4.5

Hogyan hasonlítunk össze String értékeket?
Mindig az == operátorral.
Az attól függ. Bizonyos esetekben a == operátorral.
@Mindig az equals() metódussal.
Csak ha az egyik oldal literál, akkor kell az equals() metódust alkalmazni.

Mit ír ki az alábbi kódrészlet?##int i = 5;##if (i % 2 != 0) {##  String value = "Odd";##}##System.out.println(value);
@Nem fordul le.
Odd
null
Futás közben hibával leáll.

Mit ír ki a következő kódrészlet?##String s = null;##s = "foo";##s.toUpperCase();##System.out.println(s);
Nem fordul le, mert a második sorban értékadás van, és a String immutable
@foo
FOO
Hiba futás közben

Válaszd ki a hamis állítást!
A this kulcsszó az aktuális példányra vonatkozik.
@Mivel az attribútum elfedheti a formális paramétert, a this kulcsszót kell használni.
A formális paraméter elfedheti az attribútumot.
A setter metódus feladata egy attribútum értékének beállítása.

Mit ír ki az alábbi kódrészlet?##for (int i = 3; i >=0; i--) {##  System.out.println(i);##}
@Sortöréssel elválasztva: 3 2 1 0.
Sortöréssel elválasztva: 3 2 1.
Sortöréssel elválasztva: 2 1 0.
Nem fordul le.

Melyik állítás igaz az alábbiak közül?
Java alkalmazások kizárólag fejlsztőeszközzel fejleszthetők.
@A fejlesztőeszköz is a fordítót és a JVM-et használja.
Maven nélkül nem lehet Java projektet létrehozni.
A Javaban van standard projektfelépítés, könyvtárszerkezet.

Melyik hamis az alábbi állítások közül?
@Az importáláskor csillaggal megadva beimportálhatjuk az adott csomagnak és annak összes alcsomagjának osztályát
Nem kell importálni a java.lang csomag osztályait
Az importálással más csomagban lévő osztályokat lehet használnunk, anélkül, hogy minősítenénk
Az importálás helyettesíthető azzal, hogy az osztályt csomagnévvel minősítem

Hogyan konvertálunk egy egész számot String típusú változóba (int i = 5)?
String s = i + "";
String s = Integer.toString(i);
String s = "" + i;
@Mindegyik megoldás helyes

Válaszd ki az igaz állítást!
A Maven az alkalmazás forráskódját az src/java/main könyvtárban tartalmazza
A Maven koordináták kizárólag a group és ver.
@Az mvn package paranccsal lehet lefordítani a forráskódot, valamint összecsomagolni a jar állományt.
A Maven preferálja, hogy mindent úgy adjunk meg, ahogy mi szeretnénk, azaz egyéni konfigurációkat használjunk.

Mit ír ki a következő kódrészlet?##String s = "2";##switch (s) {##  case "1":##    System.out.print("one ");##  case "2":##    System.out.print("two ");##  case "3":##    System.out.print("three ");##  default:##    System.out.print("booo ");##}
Nem fordul le, mert switch szerkezetnél nem használható String
two
@two three booo
two three

Hogyan hozol létre egy szövegből egész számot? String s = "5";
int i = s;
int i = (String) s;
int i = String.parse(s);
@int i = Integer.parseInt(s);

Amennyiben van egy s String típusú változó, hogyan alakítjuk át enum típussá?
@Weekdays w = Weekdays.valueOf(s);
Weekdays w = (Weekdays) s;
Weekdays w = new Weekdays(s);
Weekdays w = s;

Melyik állítás hamis az immutable osztályokkal kapcsolatban?
Érdemes az attribútumait final kulcsszóval ellátni, hogy csak egyszer lehessen neki értéket adni.
Használatuk azért is hasznos, mert paraméterként átadva biztosak lehetünk benne, hogy a hívás során nem változik az értéke.
A String osztály immutable
@A metódusai módosíthatják az attribútumok értékét, csak a paraméterek értékét nem módosíthatják

Melyik állítás hamis, az alábbi kódrészlet esetén?##public class TrainerData {##  private String name;##  private List<String> courses;####  public TrainerData(String name, List<String> courses) {##    this.name = name;##    this.courses = new ArrayList<>(courses);##  }####  public String getName() {##    return name;##  }####  public List<String> getCourses() {##    return courses;##  }##}
A TrainerData osztály name attribútuma osztályon kívülről módosítható, ugyanis nincs final módosítószóval ellátva
A TrainerData immutable, még a courses lista tartalma sem változtatható kívülről
A name attribútum módosítható, pl. így: new TrainerData("John Doe", Arrays.asList("Biology")).getName().toUpperCase();
@Mind a három állítás hamis

Mely igaz a JavaBeans konvenciókkal kapcsolatban?
Minden Java osztálynak JavaBeansnek kell lennie
Kötelezően lenniük kell getter és setter metódusainak
Minden típus esetén ugyanazt az elnevezést kell alkalmaznunk, get prefix, utána az attribútum neve, aminek az első karaktere nagybetű, pl. getName()
@Attribútum, és a hozzá tartozó metódusok összefoglaló neve property

Mit ír ki az alábbi kódrészlet?##public class WithName {##  private String name;####  public WithName(String name) {##    this.name = name;##  }####  public void modifyName(String name) {##    return this.name;##  }####  public static void main(String[] args) {##    System.out.println(new WithName("John Doe").modifyName("Jack Doe"));##  }##}
John Doe
Jack Doe
null
@Nem fordul le

Mit ír ki az alábbi kódrészlet?##public class Numbers {##  public String addFive(String s) {##    return s + 5;##  }####  public static void main(String[] args) {##    System.out.println(new Numbers().addFive(10));##  }##}
105
15
@Nem fordul le
Futás közben kivételt dob

Mit ír ki az alábbi kódrészlet?##public class NameConverter {##  public void convertNames(String name, List<String> otherNames) {##    name = name.toUpperCase();##    for (int i = 0; i < otherNames.size(); i++) {##      otherNames.set(i, otherNames.get(i).toUpperCase());##    }##  }####  public static void main(String[] args) {##    String name = "John Doe";##    List<String> names = new ArrayList<>(Arrays.asList("Jane Doe"));##    new NameConverter().convertNames(name, names);##    System.out.print(name);##    System.out.print(" ");##    System.out.print(names);##  }##}
@John Doe [JANE DOE]
JOHN DOE [JANE DOE]
John Doe [Jane Doe]
[John Doe, Jane Doe]

Mit ír ki az alábbi kódrészlet?##public class NameConverter {##  public String convertName(String name) {##    if (name.equals("")) {##      return;##    }##    return name.toUpperCase();##  }####  public static void main(String[] args) {##    System.out.println(new NameConverter().convertName(""));##  }##}
@Nem fordul le
Üres string, azaz ""
null
Futás közben hiba keletkezik

Melyik a helytelen módja a paraméterek bejárásának, a következő kódrészlet esetén:##public List<Course> createCourses(String... names) {##  List<Course> courses = new ArrayList<>();##  // Bejárás##}
for (String name: names) { courses.add(new Course(name)); }
@for (int i = 0; i< names.length; i++) { courses.add(new Course(names.get(i))); }
for (int i = 0; i< names.length; i++) { courses.add(new Course(names[i])); }
Egyik megadási mód sem helyes

Mit ír ki az alábbi kódrészlet?##public class Builder {##  private String name;####  public Builder setName(String name) {##    this.name = name;##    return this;##  }####  public String build() {##    return name;##  }####  public static void main(String[] args) {##    System.out.print(new Builder().build());##    System.out.print(" ");##    System.out.print(new Builder().setName("John Doe").setName("Jack Doe").build());##  }##}
Nem fordul le
@null Jack Doe
Jack Doe
null John Doe

Melyik metódussal lehet túlterhelni (overload) a következő metódust?##public Course createCourse(String name) {}
public Course create(String name) {}
public SpecificCourse createCourse(String name) {}
@public Course createCourse(String name, Level level) {}
public Course createCourse(String name) {}

A main metódusból hogyan lehet meghívni a convert metódust, az alábbi kódrészletben?##public class Concatenator {##  public static String convert(int a, int b) {##    return Integer.toString(a) + Integer.toString(b);##  }####  public static void main(String[] args) {##    // ???##  }##}
Csak a Concatenator.convert(5, 6); utasítással
Csak a convert(5, 6); utasítással
Csak a new Concatenator().convert(5, 6); utasítással
@Mindhárom utasítással, de nem mindegyik javasolt

Mit ír ki az alábbi kódrészlet?##public class State {##  private static int instance = 0;####  public State() {##    instance ++;##  }####  public static void main(String[] args) {##    new State();##    new State();##    System.out.println(instance);##  }##}
Nem fordul le
0
1
@2

Mit ír ki az alábbi kódrészlet, ha feltételezzük, hogy a két osztály két külön .java fájlban van deklarálva, a megfelelő könyvtárakban.##package foo;##public class Foo {##  public static int value = 10;##}####package bar;##import static foo.Foo;##public class Bar {##  public static void main(String[] args) {##    System.out.println(value);##  }##}
@Nem fordul le
10
0
Futás közben hiba

Melyik állítás hamis a következő kódrészletre?##public class Trainer {##  private String name;####  public Trainer(String name) {##    this.name = name;##  }##}
@Az osztály példányosítható a következő módon: Trainer t = new Trainer();
Az osztály példányosítható a következő módon: Trainer t = new Trainer("Anonymous");
Az osztály példányosítható a következő módon: Trainer t = new Trainer(null);
Nem kerül legenerálásra paraméter nélküli implicit konstruktor, hiszen van explicit konstruktor

Melyik konstruktor nem illeszhető be ebbe az osztályba harmadik konstruktorként?##public class Trainer {##  private String name;##  private int age;####  public Trainer(String name) {##    this(name, 0);##  }####  public Trainer(String name, int age) {##    this.name = name;##    this.age = age;##  }##}
public Trainer() {this(null, 0);}
public Trainer() {super();}
@public Trainer() {String name = "anonymous"; this(name);}
public Trainer(int age) { this(null, age); }

Mit ír ki az alábbi kódrészlet?##class A {##  String s = "-";##  protected A() { this("d"); s += "a"; }##  private A(String e) { s += "d"; }##}####class B extends A {##  B() { super(); s += "b"; }##}####class C extends B {##  C() { s += "c"; }##  public static void main(String... boo) {##    System.out.println((new C()).s);##  }##}
@-dabc
-abc
-adbc
-cba

Mely állítás igaz az implicit (default) konstruktorral kapcsolatban?
Fogadhat paramétereket
private módosítószóval rendelkezik
Amennyiben definiálunk egy paraméteres konstruktort, az implicit (default) konstruktor továbbra is hívható
@Törzsében szerepel egy super() hívás

Mit ír ki az alábbi kódrészlet?##class Ex1 {##  public static void main(String[] args) {##    int a[] = { 1,2,3,4}; // 1##    System.out.print(a instanceof Object); // 2##  }##}
@true
false
Nem fordul le az egyessel jelölt sor
Nem fordul le a kettessel jelölt sor

Melyik állítás hamis a Human osztály leszármazottjára (extends), a következő kódrészlet esetén:##public class Human {##  private String name;##}
Leszármazottban elérhető a name attribútum, ha a Human osztályban protected láthatósági módosítóval látjuk el
Definiáljunk egy publikus gettert az attribútumnak, és akkor a leszármazottban is hozzá lehet férni a getterrel
@A super.name hívással is hozzá lehet férni a leszármazottban
A protected módosítószó a package private kiterjesztése, használatakor nem csak az azonos csomagban lévő osztályok, hanem bármely leszármazott eléri az adott tagot

Mit kell a megjegyzés helyére írni, hogy a következő kódrészlet 12-t írjon ki?##class Mid {##  public int findMid(int n1, int n2) {##    return (n1 + n2) / 2;##  }##}####public class Calc extends Mid {##  public static void main(String[] args) {##    int n1 = 22, n2 = 2;##    // Egészítsd ki##    System.out.println(n3);##  }##}
@Calc c = new Calc(); int n3 = c.findMid(n1,n2);
int n3 = super.findMid(n1,n2);
Calc c = new Mid(); int n3 = c.findMid(n1, n2);
int n3 = this.findMid(n1,n2);

Melyik sor nem illeszthető a hiányzó kód helyére, az alábbi kódrészletben?##class Plant {##  String getName() { return "plant"; }##  Plant getType() { return this; }##}####class Flower extends Plant {##  // Hiányzó kód##}####class Tulip extends Plant { }
Tulip getType() { return new Tulip(); }
Plant getType() { return this; }
@Object getType() { return this; }
Flower getType() { return this; }

Mely deklaráció fordul le?
public abstract class Canine { public void speak(); }
public class Canine abstract { public abstract void speak(); }
public class Canine { public abstract void speak(); }
@public abstract class Canine { public void speak(){} }

Adottak a következő állítások. Az A és E osztály. A B és D interfész. A C absztrakt osztály.##Melyik helytelen a következő megadások közül?
class F implements B { }
@class F extends A, E { }
class F extends E { }
class F implements B,D { }

Adottak a következő kódrészletek. Melyik kódrészlet folytatás helytelen?##abstract class X {##  public abstract void methodX();##}####interface Y {##}
@class Z extends X implements Y { public void methodZ(); }
abstract class Z extends X implements Y { public void methodZ() {} }
class Z extends X implements Y { public void methodX() {} }
abstract class Z extends X implements Y { }

Melyik helyes deklaráció interfészen belül?
@public void doMore(long bow);
public void doMore(long bow) {}
private short hop = 23;
public Name();

Melyik írja ki a konzolra azt, hogy Hello World?
@System.out.println("Hello World")
print("Hello World")
System.console.print("Hello World")
println("Hello World")

Melyik nem primitív típus?
@String
int
char
double

Melyik Collection implementációt célszerű választanunk, ha gyakran kell elemeket hozzáadni vagy eltávolítani, azonban ritkábban index szerinti elérésre is szükség lehet, és egy elemet lehet, hogy többször is fel akarunk venni?
@LinkedList
HashMap
HashSet
ArrayList

Mi a különbség az Exception és az Error közt?
@Az Exception olyan szituációt reprezentál, ami "megoldható", míg az Error általában olyan hibát jelent, ami után nem folytatható a program futása.
Az Error olyan szituációt reprezentál, ami "megoldható", míg az Exception általában olyan hibát jelent, ami után nem folytatható a program futása.
Az Error nem a Throwable osztályból származik, míg az Exception igen.
Az Exception nem a Throwable osztályból származik, míg az Error igen.

Ha String word = "papaya", akkor melyik kifejezés adja vissza az utolsó p betű helyét?
@word.lastIndexOf("p")
word.indexOf("p")
lastIndexOf(word, p)
word.charAt(2)

Létre akarok hozni egy Object típusú példányt, és elmenteni őt egy Object típusú változóba, hogyan tudom ezt megtenni?
@Object object = new Object();
Object object = Object();
Object object = new Object;
Object = new Object();

Melyik dolog nem szerepel egy UML diagramon?
@Lokális változók
Interface implementálása
A példányváltozók láthatósága
A metódusok visszatérési értéke

Mely állítás hamis az alábbiak közül a következő kódrészlettel kapcsolatban?##public class Trainer {##  private String name;####  public Trainer(String name) {##    this.name = name;##  }##}
@Az osztály példányosítható (instantiate) a következő módon: Trainer t = new Trainer();
Az osztály példányosítható (instantiate) a következő módon: Trainer t = new Trainer("Anonymous");
Az osztály példányosítható (instantiate) a következő módon: Trainer t = new Trainer(null);
Nem kerül legenerálásra paraméter nélküli implicit (default) konstruktor, hiszen van explicit konstruktor

Válaszd ki az igaz állítást!
Az osztályok tagjai kizárólag az attribútumok (fields), metódusok és getter/setterek.
Az attribútumok (fields) speciális metódusok.
@A konstruktorok felelősek az objektum állapotának inicializálásáért.
A metódusok tárolják az attribútumok (fields) értékeit.

Egy korábbi sorban már létrehozott Object object változóm értékét szeretném felülírni egy új Object példánnyal, hogyan tudom ezt megtenni?
@object = new Object();
Object object = new Object();
object = Object();
object = new object();

Hogyan dobható Exception kézzel?
@throw new MyException();
throw MyException;
throws new MyException();
throws myException;

Melyik kulcsszóval hivatkozhatunk egy objektumon belül saját magára?
@this
instance
that
super

Mit ír ki az alábbi Java kód?##public class Test {##  public void doSomething() {##    throw new RuntimeException();##  }####  public static void main(String[] args) {##    try {##      new Test().doSomething();##    }##    catch (Throwable t) {##    System.out.println("Yupp");##    }##  }##}
Nem fordul le, mert a doSomething() metódus nem definiálja a fejben (method header) a RuntimeException kivételt (exception)
@Yupp
Az alkalmazás leáll, mert nem kezelt kivétel (unchecked exception) keletkezik
Nem ír ki semmit, az alkalmazás hiba nélkül lefut

Az alábbiak közül melyik igaz az absztrakt osztályokra?
@Származhatnak egy másik absztrakt osztályból.
Nem lehetnek példányváltozóik.
Absztrakt osztályból való leszármazáshoz az implements kulcsszót használjuk.
Csak absztrakt metódusokat tartalmazhatnak.

Melyik primitív típus?
@double
Dog
Object
String

Válaszd ki a Building osztály House alosztályának megfelelő definiálását!
@public class House extends Building {}
public subclass House extends Building {}
public class House subclass of Building {}
public class Building.House {}

Ha String word = "banana", akkor melyik kifejezés adja vissza az első a betű helyét?
@word.indexOf("a")
word.charAt(2)
word.lastIndexOf("a")
indexOf(word, "a")

Melyik metódussal NEM lehet egy booleant visszaadó metódus visszatérési értékét tesztelni?
@assertThrows
assertTrue
assertEquals
assertFalse

Melyik érvényes Java kulcsszó?
@new
main
function
Int

Melyik írja ki a konzolra a String msg változó értékét?
@System.out.println(msg)
System.console.write(msg)
msg.toString()
System.print("msg")

Melyik deklaráció írja le, hogy a metódus NullPointerException és IOException kivételt is dobbat?
public void print() throw NullPointerException | IOException
public void print() throws NullPointerException | IOException
public void print() throw NullPointerException throw IOException
@public void print() throws NullPointerException, IOException

Miért okoz fordítási hibát az alábbi kódrészlet?##List<HashMap<Queue<Boolean>, ArrayList<Set<double>>>> mess;
A List interfész, helyette valamilyen azt implementáló osztályt kell megadni
A kódrészlet nem okoz fordítási hibát
Kollekciókat nem lehet ilyen mélyen egymásba ágyazni
@Nem lehet primitív típust megadni típusparaméternek

Mit ír ki az alábbi kódrészlet? ##String s = "dog";##s.toUppercase();##System.out.println(s);
Üres sztringet
Nem fordul le
DOG
@dog

Hogyan hozható létre egy oszály új példánya?
A class kulcsszóval
Egy új fájl létrehozásával
A konstruktor meghívásával
@A new kulcsszó segítségével

Mit ír ki?##public class Main {##  public static void main (String[] args) {##    Map<String, String> someMap = new HashMap<>();##    someMap.put("someKey","someValue");##    someMap.put("someKey","someOtherValue");##    System.out.println(someMap.size() + someMap.get("someKey"));##  }##}
Futásidőben exception keletkezik, mivel a someKey kulcs már szerepel a mapben, ezért nem lehet újra felvenni.
2someOtherValue
@1someOtherValue
1someValue

Az alábbiak közül melyik nem implementálja a Collection interfacet-t?
@Enum
HashSet
ArrayList
LinkedList

Adott a következő kódrészlet. Melyik sort kell beilleszteni a komment helyére, hogy true értéket írjon ki?##public class Bird extends Animal implements CanFly {}####public interface CanFly {}####public abstract class Animal {}####public class AnimalService {##  public static void main(String[] args) {##    Bird bird = new Bird();##    // ##  }##}
System.out.print(bird.instanceof(CanFly.class))
@System.out.print(bird instanceof CanFly)
System.out.print(bird instanceof CanFly.class)
System.out.print(bird.instanceof(Animal))

Az alábiak közül melyik követi az enum értékek felsorolásának konvencióját?
Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
monday, tuesday, wednesday, thursday, friday, saturday, sunday
"MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"
@MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY

Mi a különbség a checked és az unchecked exception között?
Ha saját exceptiont írunk, az csak checked exception lehet, unchecked nem.
A catch blokk nem kapja el az unchecked exceptiont, hiszen ez jellemzően rendszerhiba.
@A checked exceptionnél a program fordításakor ellenőrzi a compiler, hogy felkészültünk-e rá, és ha nem, akkor fordítási hibát kapunk.
Unchecked exception esetén a try-catch-finally-nél a finally ág nem hajtódik végre.

Melyik nem igaz az absztrakt osztályokra?
Lehetnek példányváltozóik.
Nem példányosíthatók.
@Csak absztrakt metódusaik lehetnek.
Lehetnek absztrakt metódusaik.

Mi az a scope?
@Változók hatóköre.
Referencia egy objektumra.
Függvény visszatérési értéke.
Függvény bemenő paramétere.

Az alábbiak közül melyik nem ciklus?
@switch
while
for
do-while

Mi az enum?
@Egy típus, előre felsorolt konstansok tárolására.
Memória címek felsorolása.
A hét napjainak felsorolása.
Egy típus, előre felsorolt változók tárolására.

Mit ír ki a következő kód?##public class TestException {##  public void throwException() {##    System.out.print("throwex ");##    throw new RunTimeException();##  }####public static void main(String[] args) {##  try {##    System.out.print("try ");##    new TestException().throwException();##  } catch (Exception re) {##    System.out.print("catch ");##  } finally {##    System.out.print("finally ");##  }##  System.out.println("done");##}
try throwex catch done
try throwex finally done
@try throwex catch finally done
Futási idejű hibával megáll a program futása.

Melyik Collectionre nem igaz, hogy a benne levő elemeket ki tudom venni a hozzáadás sorrendjében?
LinkedList
ArrayDeque
@HashSet
LinkedHashSet

Mi az a konstruktor?
Új példány létrehozása
Új osztály létrehozása
@A konstruktor hasonlít egy metódusra, amely automatikusan lefut új példány létrehozásakor.
Egy változó

Milyen metódusa nincs a Collection interfésznek?
@get(K key)
size()
add(E element)
iterator()

Melyik állítás igaz?
Egy interfész tartalmazhat nem final változókat.
Egy osztály csak egy interfészt implementálhat.
@Egy absztrakt osztály tartalmazhat nem final változókat.
Az extends kulcsszóval jelöljük, ha egy osztály megvalósít interfészt.

Melyik módosító nem alkalmazható az interfészekben definiált változókon?
public
final
static
@abstract

Válaszd ki az igaz állítást!
A private módosítószóval ellátott tagok az adott csomagban látszanak.
A láthatósági módosítószóval el nem látott tagok mindenütt látszódnak.
A public módosítószóval ellátott tagok csak az adott csomagban és leszármazottjaiban látszanak.
@Az attribútumokat private láthatósággal vegyük fel, így csak az adott osztályon belül látszódnak.

Válaszd ki az igaz állítást!
Az összes csomag automatikusan importálásra kerül.
A Scanner automatikusan importálásra kerül.
A String osztályt importálni kell ahhoz, hogy használhassuk
@A java.lang csomag automatikusan importálásra kerül.

Válaszd ki az igaz állítást!
@Az osztály egy modell, és ez alapján több példány hozható létre.
Egy osztályból egy példány hozható létre.
A példányosítás során mindig új osztály születik.
Egy objektumból több példány példányosítható.

Válaszd ki a következő programrészletre igaz állítást!##List<int> numbers = new ArrayList<>();##numbers.add(0);##numbers.add(1);##numbers.add(2);
@Nem lehet primitív típussal listát létrehozni.
Autoboxing történik.
Autoboxing nélkül is működik, a lista hossza 3.
Mind a két oldalt a List szónak kell állnia a példányosítás miatt.

Melyik kulcsszó jelöl ciklust?
@while
if
switch
return

Melyik nem a kivétel kezeléshez kapcsolódó kulcsszó?
@final
try
catch
throws

Melyik primitív típus?
@char
Integer
String
Boolean[]

Hogy hívjuk azt, amikor az programunk alapegységeit teszteljük?
@Unit test
Regression test
Integration test
End-to-end test

Az alábbiak közül melyik állítás igaz?
@Több elemet egyszerre törölni a List names-ből a names.removeAll(namesToRemove); metódussal lehet, ahol a namesToRemove a törlendő elemek listája.
Az ArrayList hátterében tömb van, ezért a tömbökhöz hasonlóan előre meg kell adni a méretét létrehozáskor.
Az List names legelső elemét a names.get(1); metódussal lehet elkérni.
Bármilyen típusú érték kerülhet egy ArrayList-be, például: ArrayList<int> integers = new ArrayList<>();

Milyen operációs rendszeren lehet Java alkalmazást futtatni?
@Mindegyiken, a Java alkalmazásokat az egyes platformokra elkészített Java Virtuális Gépek (JVM) futtatják, emiatt platformfüggetlen
A Java kifejezetten a Microsoft Windows operációs rendszerhez készült programozási nyelv
A Java egy open-source programozási nyelv, ezért Linuxra készíthetünk vele programokat
A Java az Apple terméke, MacOS és IOS alkalmazásokat készíthetünk vele

Melyik változónév helyes a Clean Code alapelvek szerint?
@firstName
cc
last_name
FirstName

Melyik állítás hamis az alábbiak közül?
Az Integer.MAX_VALUE statikus változó tárolja az Integer típusú változók legnagyobb lehetséges értékét
@Véletlenszámot a Random.nextInt(100) metódushívás ad vissza
A PI értékét a Math.PI konstans tárolja
Két szám közül a nagyobbat a következő hívás adja vissza: Math.max(a, b)

Milyen metódusokat lehet meghívni a list változón, ha a következőképpen definiáljuk?##List<SomeClass> list = new ArrayList<>();
Csak az Object osztály metódusait.
@Csak a List interfész metódusait
Csak az ArrayList osztály metódusait.
Csak a Collection interfész metódusait.


